
#############################################################################################################################
# #
# # READ ME
# # 
# ##########
# 
# This file takes std-in and outputs std-out.
# The input will be a 2n by n matrix of non-negative integers delimited by a single space. 
# The first n rows are the adjacency matrix of graph one. 
# The second n rows are the adjacency matrix of graph two.
# 
# The adjacency matrices of the two difference graphs are computed. 
# Then the 2-OPT vertex covers of the difference graphs are computed, the size of one upper bounds RSN
# and the size of the other upper bounds ASN.
# Their sum upper bounds TSN. 
# 
# Type in the command line `python tda.py < tsn_input.txt > tsn_output.txt` outputs ASN, RSN and TSN
# 
# Example Input
# 
# 0 0 0 1 1
# 0 0 0 1 1
# 0 0 0 0 0
# 1 1 0 0 0
# 1 1 0 0 0
# 0 1 1 0 1
# 1 0 1 0 0
# 1 1 0 1 0
# 0 0 1 0 1
# 1 0 0 1 0
#
#
# Another example input tsn_input.txt can be generated by running the following commented block of code. 
# 
#############################################################################################################################
# #
# # Code to Generate Sample Input File
# # 
# ######################################
# 
# import networkx as nx
# import numpy as np 
# graph1 = nx.fast_gnp_random_graph(5,p=0.5)
# adj1 = nx.adjacency_matrix(graph1)
# graph2 = nx.fast_gnp_random_graph(5,p=0.5)
# adj2 = nx.adjacency_matrix(graph2)
# np.savetxt("tsn_input.txt", np.concatenate((adj1.todense(),adj2.todense())).astype(int), delimiter = ",", fmt= "%d")
# 
#############################################################################################################################

import networkx as nx 
from networkx.algorithms.approximation import min_weighted_vertex_cover
import numpy as np
import sys

std_input =  sys.stdin.read() # 2n-by-n non-negative integer matrix, representing adjacency matrices of two graphs both with |V|=n 

n = int(np.sqrt(len(std_input)/4)) # n = the vertex set size 
adj0 = np.fromstring(std_input, dtype=int, sep=' ') # transforming input into a numpy matrix
adj0 = adj0.reshape(n*2,n).astype(int)
#np.loadtxt(str(scratch), dtype='i', delimiter=' ') 
adj1 = adj0[0:n] # adjacency matrix of the first graph
adj2 = adj0[n:] # adjacency matrix of the second graph
A = np.maximum(adj1 -adj2, np.zeros((5,5))) # adj matrices of the two corresponding difference graphs
B = np.maximum(adj2 -adj1, np.zeros((5,5)))  
ga = nx.from_numpy_matrix(A) # convert the adj matrices into networkx graph object
gb = nx.from_numpy_matrix(B)
covera = min_weighted_vertex_cover(ga) # computes 2-OPT vertex cover of the difference graphs
coverb = min_weighted_vertex_cover(gb)
asn = len(covera) # ASN is upper bounded by the size of the vertex cover of one difference graph
rsn = len(coverb) # RSN is upper bounded by the size of the vertex cover of the other difference graph
tsn = asn+rsn
print(asn) 
print(rsn)
print(tsn)
